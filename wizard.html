<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Pomodoro Wizard v4.1</title>
    <style>
        :root {
            --color-bg: #0f0f1a;
            --color-primary: #ff0055;
            --color-secondary: #2a2a40;
            --color-accent: #00fff2;
            --color-text: #eaeaea;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--color-bg);
            color: var(--color-text);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* --- 3D Canvas Layer --- */
        #game-canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
            background: linear-gradient(to bottom, #0f0f1a 0%, #1a1a2e 100%);
            cursor: grab;
        }
        #game-canvas.grabbing { cursor: grabbing; }

        /* --- UI HUD Layer --- */
        .hud {
            position: absolute; z-index: 1; padding: 20px;
            pointer-events: none; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .hud__interactive { pointer-events: auto; }

        /* --- Stats Bar --- */
        .stats-bar {
            display: flex; gap: 20px; background: rgba(15, 20, 30, 0.85);
            padding: 15px; border-radius: 12px; border-bottom: 2px solid var(--color-accent);
            backdrop-filter: blur(8px); align-self: flex-start;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); min-width: 400px;
        }
        .stat { display: flex; flex-direction: column; flex: 1; }
        .stat__label { font-size: 0.75rem; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .stat__value { font-size: 1.1rem; font-weight: bold; color: #fff; }
        .stat__bar-container { width: 100%; height: 6px; background: #333; border-radius: 3px; margin-top: 6px; overflow: hidden; }
        .stat__bar-fill { height: 100%; background: var(--color-accent); width: 0%; transition: width 0.5s ease; box-shadow: 0 0 10px var(--color-accent); }
        .stat__bar-fill--stamina { background: #ffaa00; box-shadow: 0 0 10px #ffaa00; }

        /* --- Quest Board (Planner) --- */
        .quest-log {
            position: absolute; top: 100px; right: 20px; width: 340px;
            background: rgba(10, 15, 20, 0.85); border-right: 2px solid var(--color-primary);
            padding: 0; max-height: 70vh; display: flex; flex-direction: column;
            border-radius: 12px 0 0 12px; backdrop-filter: blur(5px);
            overflow: hidden;
        }

        .quest-header {
            padding: 15px; background: rgba(255,255,255,0.05);
            border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;
        }
        .quest-header h3 { font-size: 1rem; color: var(--color-primary); text-transform: uppercase; letter-spacing: 2px; margin: 0; }
        
        .add-btn {
            background: var(--color-primary); color: white; border: none;
            width: 24px; height: 24px; border-radius: 4px; cursor: pointer;
            font-weight: bold; display: flex; align-items: center; justify-content: center;
            transition: transform 0.2s;
        }
        .add-btn:hover { transform: scale(1.1); background: #ff3377; }

        .quest-content { overflow-y: auto; flex: 1; padding: 10px; }
        
        .section-title { font-size: 0.7rem; color: #666; text-transform: uppercase; margin: 10px 0 5px 0; font-weight: bold; }

        .quest-list { list-style: none; padding: 0; }
        .quest-item {
            background: linear-gradient(90deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 100%);
            margin-bottom: 6px; padding: 10px; border-radius: 6px;
            border-left: 3px solid #555; display: flex; justify-content: space-between; align-items: center;
            transition: background 0.2s;
        }
        .quest-item:hover { background: rgba(255,255,255,0.1); }
        
        /* Type Indicators */
        .quest-item.light { border-left-color: #2ecc71; }
        .quest-item.medium { border-left-color: #f1c40f; }
        .quest-item.heavy { border-left-color: #ff0055; }
        
        .quest-info { display: flex; flex-direction: column; }
        .quest-title { font-size: 0.9rem; font-weight: 500; }
        .quest-meta { font-size: 0.7rem; color: #888; }
        
        .quest-actions { display: flex; gap: 5px; }
        .action-icon { cursor: pointer; opacity: 0.6; transition: opacity 0.2s; padding: 4px; }
        .action-icon:hover { opacity: 1; transform: scale(1.1); }

        /* --- Bottom HUD --- */
        .bottom-hud {
            align-self: center; display: flex; flex-direction: column; align-items: center; gap: 15px; margin-bottom: 30px; pointer-events: auto;
        }

        .hud-timer-panel {
            background: rgba(0,0,0,0.7); padding: 15px 40px; border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(5px);
            text-align: center; display: flex; flex-direction: column; align-items: center;
            min-width: 280px; animation: fadeIn 0.3s ease;
        }
        .hud-timer-panel.hidden { display: none; }

        .hud-timer-label { font-size: 0.9rem; color: var(--color-accent); letter-spacing: 2px; text-transform: uppercase; margin-bottom: 5px; max-width: 250px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .hud-timer-value { font-size: 3rem; font-weight: bold; font-family: monospace; color: white; text-shadow: 0 0 15px var(--color-accent); line-height: 1; }
        
        .hud-timer-controls { display: flex; gap: 10px; margin-top: 15px; }
        .btn-mini { background: rgba(255,255,255,0.1); border: none; color: #aaa; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: all 0.2s; }
        .btn-mini:hover { background: rgba(255,255,255,0.2); color: white; }
        .btn-mini.finish { color: var(--color-accent); border: 1px solid var(--color-accent); }
        .btn-mini.cancel { color: var(--color-primary); }

        .controls {
            display: flex; gap: 10px; background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 50px; backdrop-filter: blur(5px); transition: opacity 0.3s;
        }
        .controls.disabled { opacity: 0.3; pointer-events: none; }

        .btn {
            background: transparent; color: white; border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 16px; border-radius: 20px; font-weight: 600; cursor: pointer; font-size: 0.9rem;
            transition: all 0.2s; display: flex; align-items: center; gap: 6px;
        }
        .btn:hover { background: rgba(255,255,255,0.1); transform: translateY(-2px); border-color: var(--color-accent); color: var(--color-accent); box-shadow: 0 0 15px rgba(0, 255, 242, 0.3); }
        .btn--xp { border-color: var(--color-accent); color: var(--color-accent); }
        .btn--heavy { border-color: var(--color-primary); color: var(--color-primary); }
        .btn--rest { border-color: #ffaa00; color: #ffaa00; }

        /* --- Overlays --- */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 15, 26, 0.95); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.3s; backdrop-filter: blur(10px);
        }
        .overlay.hidden { opacity: 0; pointer-events: none; }
        .overlay h1 { font-size: 2.5rem; margin-bottom: 10px; color: var(--color-accent); text-shadow: 0 0 20px var(--color-accent); }
        .overlay input { padding: 15px; font-size: 1.2rem; background: rgba(255,255,255,0.1); border: 1px solid #333; color: white; margin: 20px 0; text-align: center; outline: none; border-radius: 8px; width: 300px; }
        
        .plan-options { display: flex; gap: 10px; margin-top: 20px; }
        .plan-btn { padding: 15px; border-radius: 8px; border: 1px solid #444; background: rgba(255,255,255,0.05); color: #aaa; cursor: pointer; transition: all 0.2s; flex: 1; text-align: center; }
        .plan-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .plan-btn.light { border-color: #2ecc71; color: #2ecc71; }
        .plan-btn.medium { border-color: #f1c40f; color: #f1c40f; }
        .plan-btn.heavy { border-color: #ff0055; color: #ff0055; }

        /* Toast Container fixed z-index and animation */
        .toast-container { 
            position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%); z-index: 200; 
            display: flex; flex-direction: column; gap: 10px; pointer-events: none; 
        }
        .toast { 
            background: rgba(0,0,0,0.9); color: white; padding: 12px 24px; border-radius: 30px; 
            border: 1px solid var(--color-accent); animation: floatUp 2.5s forwards; 
            font-weight: bold; text-align: center; box-shadow: 0 0 15px rgba(0,255,242,0.3);
        }
        
        /* Fixed Keyframes for Visibility */
        @keyframes floatUp { 
            0% { opacity: 0; transform: translateY(20px) scale(0.9); } 
            15% { opacity: 1; transform: translateY(0) scale(1); } 
            85% { opacity: 1; transform: translateY(-30px); } 
            100% { opacity: 0; transform: translateY(-50px); } 
        }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .drag-hint { position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.3); font-size: 0.8rem; pointer-events: none; }

    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>
    <div class="drag-hint">Drag to rotate camera</div>

    <!-- HUD -->
    <div class="hud">
        <!-- Stats -->
        <div class="stats-bar hud__interactive">
            <div class="stat">
                <span class="stat__label">Code Wizard</span>
                <span class="stat__value" id="char-name-display">Player</span>
            </div>
            <div class="stat">
                <span class="stat__label">Lvl <span id="level-val">1</span> <span id="gear-label" style="font-size:0.7em; color:var(--color-primary)"></span></span>
                <div class="stat__bar-container">
                    <div class="stat__bar-fill" id="xp-bar" style="width: 0%"></div>
                </div>
            </div>
            <div class="stat">
                <span class="stat__label">Focus Stamina</span>
                <div class="stat__bar-container">
                    <div class="stat__bar-fill stat__bar-fill--stamina" id="stamina-bar"></div>
                </div>
            </div>
        </div>

        <!-- Quest Board -->
        <div class="quest-log hud__interactive">
            <div class="quest-header">
                <h3>Quest Board</h3>
                <button class="add-btn" onclick="rpgSystem.openPlanner()" title="Add Task">+</button>
            </div>
            <div class="quest-content">
                <div class="section-title">Planned</div>
                <ul class="quest-list" id="planned-list">
                    <!-- Planned tasks go here -->
                </ul>

                <div class="section-title" style="margin-top: 20px; opacity: 0.6;">History</div>
                <ul class="quest-list" id="history-list" style="opacity: 0.6;">
                    <!-- Completed logs go here -->
                </ul>
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="bottom-hud">
            <!-- TIMER PANEL -->
            <div id="hud-timer-panel" class="hud-timer-panel hidden">
                <div id="hud-timer-label" class="hud-timer-label">Focusing</div>
                <div id="hud-timer-val" class="hud-timer-value">25:00</div>
                <div class="hud-timer-controls">
                    <button class="btn-mini cancel" onclick="rpgSystem.cancelAction()">‚úï Stop</button>
                    <button id="hud-finish-btn" class="btn-mini finish" onclick="rpgSystem.finishAction()">‚úì Done</button>
                </div>
            </div>

            <!-- QUICK CONTROLS -->
            <div class="controls hud__interactive" id="controls-bar">
                <span style="font-size:0.7rem; color:#666; align-self:center; margin-right:5px;">QUICK START:</span>
                <button class="btn btn--xp" onclick="rpgSystem.quickStart('light')">üü¢ 5m</button>
                <button class="btn btn--xp" onclick="rpgSystem.quickStart('medium')">üü° 15m</button>
                <button class="btn btn--heavy" onclick="rpgSystem.quickStart('heavy')">üî¥ 25m</button>
                <button class="btn btn--rest" onclick="rpgSystem.startRest()">üí§ Sleep</button>
            </div>
        </div>
    </div>

    <!-- START SCREEN -->
    <div class="overlay" id="login-overlay">
        <h1>RPG DASHBOARD</h1>
        <p style="color: #888;">Planner Update v4.1</p>
        <input type="text" id="char-name-input" placeholder="Character Name" autocomplete="off" onkeypress="if(event.key==='Enter') startGame()">
        <button class="btn btn--xp" onclick="startGame()">Start World</button>
    </div>

    <!-- PLANNER MODAL -->
    <div class="overlay hidden" id="planner-modal">
        <h1 id="modal-title">Plan New Quest</h1>
        <input type="text" id="plan-input" placeholder="Task Name..." autocomplete="off">
        
        <p style="margin-bottom: 5px;">Select Difficulty:</p>
        <div class="plan-options">
            <div class="plan-btn light" onclick="rpgSystem.addPlannedTask('light')">
                <b>Light</b><br><small>5m (+50XP)</small>
            </div>
            <div class="plan-btn medium" onclick="rpgSystem.addPlannedTask('medium')">
                <b>Medium</b><br><small>15m (+150XP)</small>
            </div>
            <div class="plan-btn heavy" onclick="rpgSystem.addPlannedTask('heavy')">
                <b>Heavy</b><br><small>25m (+500XP)</small>
            </div>
        </div>
        <button class="btn btn--danger" style="margin-top: 20px;" onclick="document.getElementById('planner-modal').classList.add('hidden')">Cancel</button>
    </div>

    <div class="toast-container" id="toast-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- GAME LOGIC ---
        const gameState = {
            name: "Dev",
            level: 1,
            xp: 0,
            xpToNext: 1000,
            stamina: 100,
            plannedTasks: [],
            completedTasks: [],
            activeTask: null,
            timerInterval: null
        };

        const gearUnlocks = {
            2: "Staff Acquired",
            3: "Cape Acquired",
            5: "Crown of Focus",
            10: "God Mode"
        };

        const taskDefinitions = {
            light: { t: "Light", m: 5, x: 50, s: 5 },
            medium: { t: "Medium", m: 15, x: 150, s: 15 },
            heavy: { t: "Heavy", m: 25, x: 500, s: 30 }
        };

        const rpgSystem = {
            updateUI: () => {
                document.getElementById('char-name-display').innerText = gameState.name;
                document.getElementById('level-val').innerText = gameState.level;
                
                const xpPercent = (gameState.xp / gameState.xpToNext) * 100;
                document.getElementById('xp-bar').style.width = `${xpPercent}%`;
                
                const stamBar = document.getElementById('stamina-bar');
                stamBar.style.width = `${gameState.stamina}%`;
                stamBar.style.backgroundColor = gameState.stamina < 30 ? "#e74c3c" : "#ffaa00";

                if (typeof scene !== 'undefined' && scene && scene.fog) {
                    scene.fog.color.setHex(gameState.stamina < 30 ? 0x111111 : 0x1a1a2e);
                    scene.fog.density = gameState.stamina < 30 ? 0.08 : 0.02;
                }

                rpgSystem.renderBoards();
                updateWizardGear();
            },

            renderBoards: () => {
                // Render Planned
                const pList = document.getElementById('planned-list');
                pList.innerHTML = '';
                if(gameState.plannedTasks.length === 0) {
                    pList.innerHTML = '<li style="text-align:center; color:#444; font-size:0.8rem; padding:10px;">No quests planned</li>';
                }
                gameState.plannedTasks.forEach(t => {
                    const li = document.createElement('li');
                    li.className = `quest-item ${t.type}`;
                    li.innerHTML = `
                        <div class="quest-info">
                            <span class="quest-title">${t.title}</span>
                            <span class="quest-meta">${taskDefinitions[t.type].m}m | +${taskDefinitions[t.type].x}XP</span>
                        </div>
                        <div class="quest-actions">
                            <span class="action-icon" onclick="rpgSystem.startPlannedTask(${t.id})" title="Start">‚ñ∂Ô∏è</span>
                            <span class="action-icon" onclick="rpgSystem.deletePlannedTask(${t.id})" title="Delete">üóëÔ∏è</span>
                        </div>
                    `;
                    pList.appendChild(li);
                });

                // Render History
                const hList = document.getElementById('history-list');
                hList.innerHTML = '';
                gameState.completedTasks.slice(-5).reverse().forEach(t => {
                    const li = document.createElement('li');
                    li.className = `quest-item ${t.type}`;
                    li.innerHTML = `<span class="quest-title">${t.title}</span><span class="quest-item__reward">Done</span>`;
                    hList.appendChild(li);
                });
            },

            // --- PLANNER LOGIC ---
            openPlanner: () => {
                document.getElementById('plan-input').value = "";
                document.getElementById('planner-modal').classList.remove('hidden');
                document.getElementById('plan-input').focus();
            },

            addPlannedTask: (type) => {
                const title = document.getElementById('plan-input').value || `${type.charAt(0).toUpperCase() + type.slice(1)} Task`;
                const newTask = {
                    id: Date.now(),
                    title: title,
                    type: type,
                    xp: taskDefinitions[type].x,
                    cost: taskDefinitions[type].s,
                    duration: taskDefinitions[type].m * 60
                };
                gameState.plannedTasks.push(newTask);
                document.getElementById('planner-modal').classList.add('hidden');
                rpgSystem.updateUI();
                rpgSystem.showToast("üìå Quest Added to Board");
            },

            deletePlannedTask: (id) => {
                gameState.plannedTasks = gameState.plannedTasks.filter(t => t.id !== id);
                rpgSystem.updateUI();
            },

            startPlannedTask: (id) => {
                const task = gameState.plannedTasks.find(t => t.id === id);
                if (!task) return;
                
                // Check Stamina
                if (gameState.stamina <= 10) return rpgSystem.showToast("üö´ Too tired! Sleep first.");

                // Move from planned to active logic
                gameState.activeTask = { ...task }; // Copy task
                // Remove from planned list
                gameState.plannedTasks = gameState.plannedTasks.filter(t => t.id !== id);
                
                rpgSystem.updateUI();
                rpgSystem.initTimerUI(false); // Start Work Timer
            },

            quickStart: (type) => {
                if (gameState.stamina <= 10) return rpgSystem.showToast("üö´ Too tired! Sleep first.");
                const def = taskDefinitions[type];
                gameState.activeTask = { 
                    title: "Quick Quest", type, xp: def.x, cost: def.s, duration: def.m * 60 
                };
                rpgSystem.initTimerUI(false);
            },

            startRest: () => {
                gameState.activeTask = { type: 'rest', xp: 0, cost: 0, duration: 5 * 60, title: "Recharging..." };
                rpgSystem.initTimerUI(true);
            },

            // --- TIMER ENGINE ---
            initTimerUI: (isRest) => {
                document.getElementById('controls-bar').classList.add('disabled');
                document.getElementById('hud-timer-panel').classList.remove('hidden');
                
                if (isRest) {
                    document.getElementById('hud-timer-label').innerText = "RECHARGING...";
                    document.getElementById('hud-timer-label').style.color = "#ffaa00";
                    document.getElementById('hud-finish-btn').style.display = 'none';
                    startWizardRest(true);
                } else {
                    document.getElementById('hud-timer-label').innerText = gameState.activeTask.title;
                    document.getElementById('hud-timer-label').style.color = "#00fff2";
                    document.getElementById('hud-finish-btn').style.display = 'inline-block';
                    startWizardFocus(true);
                }

                let timeLeft = gameState.activeTask.duration;
                updateTimerDisplay(timeLeft);

                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                gameState.timerInterval = setInterval(() => {
                    timeLeft--;
                    updateTimerDisplay(timeLeft);
                    if (timeLeft <= 0) {
                        clearInterval(gameState.timerInterval);
                        rpgSystem.finishAction();
                    }
                }, 1000); // 1000ms = 1s. Set to 10 for testing speed.
            },

            finishAction: () => {
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                const task = gameState.activeTask;
                
                document.getElementById('hud-timer-panel').classList.add('hidden');
                document.getElementById('controls-bar').classList.remove('disabled');
                
                startWizardFocus(false);
                startWizardRest(false);

                if (task.type === 'rest') {
                    gameState.stamina = 100;
                    rpgSystem.showToast("üîã ENERGY RESTORED!");
                } else {
                    gameState.stamina = Math.max(0, gameState.stamina - task.cost);
                    gameState.xp += task.xp;
                    gameState.completedTasks.push({ title: task.title, xp: task.xp, type: task.type });
                    rpgSystem.showToast(`‚ú® COMPLETE! +${task.xp} XP`);
                    
                    if(elements.wizardGroup) {
                        elements.wizardGroup.position.y += 1;
                        // Simple FX
                        const flash = new THREE.PointLight(0xffffff, 2, 10);
                        flash.position.set(0,2,0);
                        scene.add(flash);
                        setTimeout(() => scene.remove(flash), 200);
                    }
                    if (gameState.xp >= gameState.xpToNext) rpgSystem.levelUp();
                }
                rpgSystem.updateUI();
            },

            cancelAction: () => {
                if (gameState.timerInterval) clearInterval(gameState.timerInterval);
                document.getElementById('hud-timer-panel').classList.add('hidden');
                document.getElementById('controls-bar').classList.remove('disabled');
                startWizardFocus(false);
                startWizardRest(false);
                rpgSystem.showToast("üõë Cancelled");
                
                // If it was a planned task, maybe add it back? For now, it's lost (punishment for cancelling!)
                rpgSystem.updateUI();
            },

            levelUp: () => {
                gameState.level++;
                gameState.xp -= gameState.xpToNext;
                gameState.xpToNext = Math.floor(gameState.xpToNext * 1.3);
                rpgSystem.showToast(`üéâ LEVEL ${gameState.level} BEREIKT!`);
                if(gearUnlocks[gameState.level]) setTimeout(() => rpgSystem.showToast(`‚öîÔ∏è ITEM: ${gearUnlocks[gameState.level]}`), 1500);
                rpgSystem.updateUI();
            },

            showToast: (msg) => {
                const div = document.createElement('div');
                div.className = 'toast'; div.innerText = msg;
                document.getElementById('toast-container').appendChild(div);
                setTimeout(() => div.remove(), 2500);
            }
        };

        function updateTimerDisplay(seconds) {
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = (seconds % 60).toString().padStart(2, '0');
            document.getElementById('hud-timer-val').innerText = `${m}:${s}`;
        }

        // --- 3D ENGINE ---
        let scene, camera, renderer, elements = {};
        let spinSpeed = 1; let isFocusing = false;
        let cameraAngle = 0; const cameraRadius = 13;
        let isDragging = false; let previousMouseX = 0;

        function initWorld() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a1a2e, 0.02);
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const canvas = document.getElementById('game-canvas');
            canvas.addEventListener('mousedown', (e) => { isDragging = true; previousMouseX = e.clientX; canvas.classList.add('grabbing'); });
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    cameraAngle -= (e.clientX - previousMouseX) * 0.005;
                    updateCameraPosition();
                    previousMouseX = e.clientX;
                }
            });
            window.addEventListener('mouseup', () => { isDragging = false; canvas.classList.remove('grabbing'); });

            const ambient = new THREE.AmbientLight(0x404040, 1.5); scene.add(ambient);
            const moonLight = new THREE.DirectionalLight(0xaaccff, 0.8); moonLight.position.set(-10, 20, -10); moonLight.castShadow = true; scene.add(moonLight);
            
            elements.magicLight = new THREE.PointLight(0x00fff2, 0, 20); elements.magicLight.position.set(0, 5, 0); scene.add(elements.magicLight);

            createLandscape(); createWizard(); animate();
        }

        function updateCameraPosition() {
            camera.position.set(Math.sin(cameraAngle) * cameraRadius, 4, Math.cos(cameraAngle) * cameraRadius);
            camera.lookAt(0, 2, 0);
        }

        function createLandscape() {
            const ground = new THREE.Mesh(new THREE.CylinderGeometry(40, 40, 1, 64), new THREE.MeshStandardMaterial({ color: 0x112233, flatShading: true }));
            ground.position.y = -0.5; ground.receiveShadow = true; scene.add(ground);

            for(let i=0; i<80; i++) {
                const angle = Math.random() * Math.PI * 2; const radius = 6 + Math.random() * 30;
                const x = Math.cos(angle) * radius; const z = Math.sin(angle) * radius;
                if (Math.abs(x) < 3 && z > 5 && z < 15) continue;

                if (Math.random() > 0.3) {
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 1.5, 6), new THREE.MeshStandardMaterial({ color: 0x3d2817 }));
                    const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5, 4, 8), new THREE.MeshStandardMaterial({ color: 0x2d4c3b }));
                    leaves.position.y = 2.5; trunk.add(leaves); trunk.position.set(x, 0.75, z); trunk.castShadow = true;
                    const s = 0.8 + Math.random() * 0.5; trunk.scale.set(s,s,s); scene.add(trunk);
                } else {
                    const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(1 + Math.random()), new THREE.MeshStandardMaterial({ color: 0x444455, flatShading: true }));
                    rock.position.set(x, 0, z); rock.rotation.set(Math.random(), Math.random(), Math.random()); scene.add(rock);
                }
            }
            
            const pGeo = new THREE.BufferGeometry(); const pCount = 300; const pPos = new Float32Array(pCount * 3);
            for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random() - 0.5) * 60;
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            elements.particles = new THREE.Points(pGeo, new THREE.PointsMaterial({ size: 0.1, color: 0x00fff2, transparent: true, opacity: 0.6 }));
            scene.add(elements.particles);
        }

        function createWizard() {
            const group = new THREE.Group();
            
            const robe = new THREE.Mesh(new THREE.ConeGeometry(1.2, 3.5, 7), new THREE.MeshStandardMaterial({ color: 0x222244, flatShading: true }));
            robe.position.y = 1.75; robe.castShadow = true; group.add(robe);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 12, 12), new THREE.MeshStandardMaterial({ color: 0xffccaa }));
            head.position.y = 3.2; group.add(head);

            const hatGroup = new THREE.Group();
            hatGroup.add(new THREE.Mesh(new THREE.ConeGeometry(0.8, 2, 8), new THREE.MeshStandardMaterial({ color: 0x111122 })).translateX(0).translateY(1).rotateX(-0.2));
            hatGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.1, 8), new THREE.MeshStandardMaterial({ color: 0x111122 })));
            hatGroup.position.y = 3.5; group.add(hatGroup);

            elements.handR = new THREE.Group(); elements.handR.position.set(1.0, 2.2, 0.6); group.add(elements.handR);
            elements.backSlot = new THREE.Group(); elements.backSlot.position.set(0, 3, -0.8); group.add(elements.backSlot);
            elements.headSlot = new THREE.Group(); elements.headSlot.position.set(0, 4.2, 0); group.add(elements.headSlot);

            scene.add(group); elements.wizardGroup = group;
        }

        function updateWizardGear() {
            if (gameState.level >= 2 && !elements.hasStaff) {
                const staff = new THREE.Group();
                staff.add(new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 4), new THREE.MeshStandardMaterial({ color: 0x5c4033 })));
                const gem = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3), new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0xff0055 }));
                gem.position.y = 2; staff.add(gem);
                staff.rotation.set(0.2, 0, -0.3); elements.handR.add(staff); elements.hasStaff = true;
            }
            if (gameState.level >= 3 && !elements.hasCape) {
                const cape = new THREE.Mesh(new THREE.BoxGeometry(1.4, 2.5, 0.1), new THREE.MeshStandardMaterial({ color: 0xaa0033 }));
                cape.position.y = -1; cape.rotation.x = 0.3; elements.backSlot.add(cape); elements.cape = cape; elements.hasCape = true;
            }
            if (gameState.level >= 5 && !elements.hasCrown) {
                const crown = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.05, 8, 32), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
                crown.rotation.x = Math.PI / 2; elements.headSlot.add(crown); elements.hasCrown = true;
            }
        }

        function startWizardFocus(active) {
            isFocusing = active;
            if(active) {
                elements.wizardGroup.position.y = 1; elements.magicLight.intensity = 2; elements.particles.material.color.setHex(0xff0055);
            } else {
                elements.wizardGroup.position.y = 0; elements.magicLight.intensity = 0; elements.particles.material.color.setHex(0x00fff2);
            }
        }

        function startWizardRest(active) {
            if(active) { elements.wizardGroup.position.y = -0.5; elements.wizardGroup.rotation.x = 0.2; }
            else { elements.wizardGroup.position.y = 0; elements.wizardGroup.rotation.x = 0; }
        }

        function animate() {
            requestAnimationFrame(animate); const time = Date.now() * 0.001;
            if (elements.wizardGroup && !isFocusing) {
                elements.wizardGroup.position.y = Math.sin(time) * 0.2 + (gameState.stamina < 30 ? -0.5 : 0);
                elements.wizardGroup.rotation.y += 0.01 * spinSpeed;
                if (elements.cape) elements.cape.rotation.x = 0.3 + Math.sin(time * 5) * 0.1;
            } else if (elements.wizardGroup && isFocusing) {
                elements.wizardGroup.rotation.y += 0.05; elements.wizardGroup.position.y = 1 + Math.sin(time * 5) * 0.1;
            }
            if (elements.particles) elements.particles.rotation.y = time * (isFocusing ? 0.2 : 0.05);
            renderer.render(scene, camera);
        }

        function startGame() {
            const name = document.getElementById('char-name-input').value || "Dev";
            gameState.name = name;
            document.getElementById('login-overlay').classList.add('hidden');
            initWorld(); rpgSystem.updateUI();
        }
        
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

    </script>
</body>
</html>
